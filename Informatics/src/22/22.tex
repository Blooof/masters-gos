\documentclass[a4paper,12pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}

\begin{document}
\section*{22. Метод Model checking. Модель Крипке. Линейная темпоральная логика: cинтаксис, семантика, примеры формул. Автомат Бюхи. Верификация LTL при помощи автоматов Бюхи.}
\url{http://is.ifmo.ru/verification/velder_verification_posobie.pdf}


\textbf{Модель Крипке}(стр. 30).

\textbf{Атомарные предложения} -- это базовые
предложения, которые могут быть сделаны. Множество атомарных
предложений обозначается $AP$. Примерами атомарных предложений
являются предложения «$x$ больше 0» или «$x$ равно 1» для некоторой
переменной $x$. Другими примерами таких предложений являются
«идет дождь» или «в магазине нет покупателей». В принципе,
атомарные предложения определяются над множеством переменных
$x, y, \ldots$, констант $0, 1, 2, \ldots$, функций $max, gcd, \ldots$ и предикатов
$x = 2,\ x\ mod\ 2 = 0, \ldots$; допускаются предложения вида $max(x, y) \le 3$ или $x = y$.

\textbf{Моделью Крипке} (структурой Крипке) над множеством атомарных
предложений $AP$ называется тройка $(S, R, Label)$, где
\begin{itemize}
    \item $S$ – непустое множество состояний;
    \item $R \subset S \times S$ – тотальное отношение переходов на $S$, которое сопоставляет элементу $s \in S$ его возможных потомков;
    \item $Label: S \rightarrow 2^{AP}$ сопоставляет каждому состоянию $s \in S$ атомарные предложения $Label(s)$, которые верны в $s$.
\end{itemize}
Отношение $R \subset S \times S$ называется тотальным, если оно ставит в
соответствие каждому состоянию $s \in S$ как минимум одного потомка
$(\forall s \in S: \exists s' \in S: (s, s') \in R)$.
Иногда еще требуют, чтобы для модели Крипке был задан набор
начальных состояний $S_0 \subset S$.
Путь в модели Крипке из состояния $s_0$ – это бесконечная
последовательность состояний $\pi = s_0 s_1 s_2 \ldots$ такая, что для всех $i \ge 0$
выполняется $R(s_i, s_{i+1})$.

\textbf{Синтаксис LTL}(стр. 35).

Пусть $AP$ – множество атомарных предложений. Тогда:
\begin{enumerate}
    \item p является формулой для всех $p \in AP$.
    \item Если $\phi$ – формула, то $\lnot \phi$ – формула.
    \item Если $\phi$ и $\psi$ – формулы, то $\phi \vee \psi$ – формула.
    \item Если $\phi$ – формула, то $X\ \phi$ – формула.
    \item Если $\phi$ и $\psi$ – формулы, то $\phi\ U\ \psi$ – формула.
\end{enumerate}
Множество формул, построенных в соответствии с этими правилами,
называется формулами LTL.

Заметим, что множество формул, полученных на основе первых трех
пунктов, определяет множество всех формул пропозициональной
логики. Пропозициональная логика является, таким образом,
собственным подмножеством LTL. Темпоральными операторами
являются только $X$ (neXt) и $U$ (Until).

Еще формулы:
\begin{itemize}
    \item $\phi \wedge \psi = \lnot (\lnot \phi \vee \lnot \psi)$;
    \item $\phi \rightarrow \psi = \lnot \phi \vee \psi$;
    \item $\phi \leftrightarrow \psi = (\phi \rightarrow \psi) \wedge (\psi \rightarrow \psi)$;
    \item $true = \phi \vee \lnot \phi$;
    \item $false = \lnot true$;
    \item $F\ \phi = true\ U\ \phi$;
    \item $G\ \phi = \lnot F\ \lnot \phi$.
\end{itemize}
$F$ -- Future, $G$ -- Globally.

Итак, можно утверждать, что формула без темпорального оператора
($X$, $F$, $G$, $U$) на <<верхнем уровне>> относится к текущему состоянию,
формула $X\ \phi$ -- к следующему состоянию, $G\ \phi$ -- ко всем будущим
состояниям, $F\ \phi$ -- к некоторому будущему состоянию, а $U$ – ко всем
будущим состояниям до тех пор, пока определенное условие не станет
верным.

\textbf{Семантика LTL}(стр. 37).

LTL-модель – это тройка $M = (S, R, Label)$, в которой:
\begin{itemize}
    \item $S$ – непустое конечное множество состояний;
    \item $R: S \rightarrow S$ сопоставляет элементу $s \in S$ единственный следующий за
ним элемент $R(S)$;
    \item $Label: S \rightarrow 2^{AP}$ сопоставляет каждому состоянию $s \in S$ атомарные
предложения $Label(s)$, которые верны в $s$.
\end{itemize}
Для состояния $s \in S$ состояние $R(S)$ – единственное состояние,
следующее за $s$. Важной характеристикой функции $R$ является то, что
она работает как генератор бесконечных последовательностей $s, R(S),
R(R(S)), R(R(R(S))), \ldots$ Последовательности состояний для семантики
LTL являются краеугольным камнем. Можно с тем же успехом
определить LTL-модель как структуру $(S, \sigma, Label)$, где $\sigma$ --
бесконечная последовательность состояний, а $S$ и $Label$ определены,
как это сделано выше.

Функция $Label$ указывает, какие атомарные предложения верны для
заданного состояния $M$. Если для состояния $s$ имеем $Label(s) = \varnothing$, то
это означает, что ни одно атомарное предложение не верно в
состоянии $s$. Состояние $s$, в котором предложение $p$ верно
($p \in Label(s)$), иногда называется $p$-состоянием.

Смысл формул в логике определяется в терминах отношения
выполняемости (обозначаемого $\vDash$) между моделью $M$, одним из ее
состояний $s$ и формулой $\phi$.

$(M, s, \phi) \in \vDash$ обозначается в инфиксной нотации: $M, s \vDash \phi$. Идея
заключается в том, что $M, s \vDash \phi$ тогда и только тогда, когда $\phi$ верно в
состоянии $s$ модели $M$. Когда модель $M$ ясна из контекста, будем
опускать модель и писать $s \vDash \phi$ вместо $M, s \vDash \phi$.
Семантика LTL определяется следующим образом. Пусть $p \in AP$ --
атомарное предложение, $M = (S, R, Label)$ -- LTL-модель, $s \in S$ и $\phi, \psi$ --
LTL-формулы. Отношение выполняемости $\vDash$ задается таким
способом:
\begin{align*}
    &s \vDash p &&\Leftrightarrow p \in Label(s);\\
    &s \vDash \lnot \phi &&\Leftrightarrow \lnot(s \vDash \phi);\\
    &s \vDash (\phi \vee \psi) &&\Leftrightarrow (s \vDash \phi) \vee (s \vDash \psi);\\
    &s \vDash X \phi &&\Leftrightarrow R(s) \vDash \psi;\\
    &s \vDash (\phi U \psi) &&\Leftrightarrow \exists j \ge 0: R^j(s) \vDash \psi \wedge (\forall 0 \le k < j: R^k(s) \vDash \phi).
\end{align*}
Здесь $R^0(s) = s$ и $R^{n+1}(s) = R(R^n(s))$ для любого $n \ge 0$.
Если $R(s) = s'$, то состояние $s'$ называется прямым потомком $s$. Если
$R^n(s) = s'$ для $n \ge 1$, то состояние $s'$ называется потомком $s$. Если
$M, s \vDash \phi$, то говорят, что модель $M$ удовлетворяет формуле $\phi$ в
состоянии $s$. Иначе говоря, формула $\phi$ выполняется в состоянии $s$
модели $M$.

Примеры на стр. 40-41.

\textbf{Автомат Бюхи}(стр. 62).

Пусть $AP$ -- множество атомарных предложений. Автоматом Бюхи
над алфавитом $2^{AP}$ называется четверка $A = (Q, q_0, \delta, F)$, где
\begin{itemize}
    \item $Q$ -- конечное множество состояний;
    \item $q_0$ -- начальное состояние;
    \item $\delta \subset Q \times 2^{AP} \times Q$ -- тотальное отношение переходов;
    \item $F \subset Q$ -- множество допускающих состояний.
\end{itemize}
Опишем алгоритм Герта, Пеледа, Варди и Волпера для
построения автомата Бюхи по LTL-формуле. Введем новый
темпоральный оператор $R$ (Release), который определяется
следующим образом:
$$\phi R \psi = \lnot(\lnot \phi\ U\ \lnot \psi).$$
Для него верно, например, аналогичное тождество расширения:
$$\phi R \psi \equiv \psi \wedge (\phi \vee X(\phi\ R\ \psi)).$$
Для работы алгоритма требуется, чтобы LTL-формула была приведена
в негативную нормальную форму -- отрицание должно применяться
только к атомарным предложениям.
Опишем метод приведения LTL-формулы к негативной нормальной
форме.
\begin{enumerate}
    \item Заменим все подформулы вида $F \phi$ на $true\ U\ \phi$.
    \item Заменим все подформулы вида $G \phi$ на $false\ R\ \phi$.
    \item Используя булевы тождества, оставим в формуле только три логические операции: $\lnot, \vee, \wedge$.
    \item Используя тождества LTL
    \begin{itemize}
        \item $\lnot (\phi\ U\ \psi) \equiv \lnot \phi\ R\ \lnot \psi$;
        \item $\lnot (\phi\ R\ \psi) \equiv \lnot \phi\ U\ \lnot \psi$;
        \item $\lnot X\ \phi \equiv X\ \lnot \phi$,
    \end{itemize}
    погружаем отрицания внутрь темпоральных операторов
\end{enumerate}
Для алгоритма потребуются следующие структуры данных:
\begin{itemize}
    \item UID – уникальный идентификатор;
    \item Formula – LTL-формула;
    \item Node – вершина графа переходов автомата Бюхи.
\end{itemize}
Для алгоритма неважно, в каком виде будут представлены
уникальные идентификаторы и формулы, поэтому опишем только
структуру Node.
\lstset{
    language=C,
    basicstyle=\small\ttfamily,
    frame=single,
    captionpos=b
}
\begin{lstlisting}
struct Node
{
    UID id;
    list<NodeID> incoming;
    list<Formula> old;
    list<Formula> new;
    list<Formula> next;
};
\end{lstlisting}
Здесь $incoming$ – список вершин-предшественников (вершин, из
которых идет дуга в текущую вершину). В полях $old$, $new$ и $next$
содержатся списки подформул исходной формулы.

Функция $CreateAutomaton$ строит граф переходов
автомата Бюхи по формуле $f$.
\begin{lstlisting}[mathescape]
list<Node> CreateAutomaton (Formula f)
{
    Node n;
    n.incoming = {init};
    n.old = $\varnothing$;
    n.new = {f};
    n.next = $\varnothing$;
    return Expand(n, $\varnothing$);
}
\end{lstlisting}
Добавление новой вершины выполняется функцией $Expand$.
Код на стр. 63-65.

\textbf{Верификация LTL при помощи автоматов Бюхи}(стр. 67).

Пусть даны модель Крипке и LTL-формула, выполнение которой на
модели требуется проверить. Общая идея алгоритма следующая:
\begin{itemize}
    \item Из отрицания LTL-формулы строится эквивалентный ей автомат
Бюхи.
    \item Модель Крипке также преобразуется в автомат Бюхи.
    \item Строится третий автомат Бюхи как пересечение первых двух.
Такой автомат будет допускать пути исходной модели, которые не
удовлетворяют LTL-формуле спецификации.
    \item Если язык, допускаемый построенным автоматом-пересечением,
пуст, то верификация успешна. Если нет, то путь, допускаемый
автоматом-пересечением, является контрпримером.
\end{itemize}
\end{document}